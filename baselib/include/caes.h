#ifndef _CAES_H_
#define _CAES_H_

/*!
 * \file caes.h
 * \author FelitHuang
 * \remark AES 加密解密
*/

#include <string>
#include <openssl/aes.h>

// KBIT=[128, 192, 256]
template<int KBIT>
class CAES
{
public:
	CAES() : m_keyEncrypt(), m_keyDecrypt()
	{
	}

	CAES(const std::string& sKey)
	{
		setKey(sKey);
	}

public:
	CAES& setKey(const std::string& sKey)
	{
		unsigned char ucKey[KBIT/8] = {0};
		for (size_t KI=0; KI<sKey.size(); ++KI)
		{
			ucKey[KI%(KBIT/8)] ^= sKey[KI];
		}
		AES_set_encrypt_key(ucKey, KBIT, &m_keyEncrypt);
		AES_set_decrypt_key(ucKey, KBIT, &m_keyDecrypt);
		return *this;
	}

	std::string encrypt(const std::string& sData)
	{
		int iAlen = 16-sData.size()%16;
		std::string sFData(sData.size()+iAlen, iAlen);
		sData.copy(&sFData[0], sData.size(), 0);

		std::string sResult(sFData.size(), (char)0);

		for (size_t nSize=0; nSize<sFData.size(); nSize+=16)
		{
			AES_encrypt((unsigned char*)&sFData[nSize], (unsigned char*)&sResult[nSize], &m_keyEncrypt);
		}

		return sResult;
	}

	std::string decrypt(const std::string& sData)
	{
		if (sData.size()==0 || sData.size()%16!=0)
		{
			return "";
		}

		std::string sResult(sData.size(), (char)0);

		for (size_t nSize=0; nSize<sData.size(); nSize+=16)
		{
			AES_decrypt((unsigned char*)&sData[nSize], (unsigned char*)&sResult[nSize], &m_keyDecrypt);
		}

		size_t nAlen = (unsigned char)sResult[sResult.size()-1];
		if (nAlen>16)
		{
			return "";
		}

		return sResult.substr(0, sResult.size()-nAlen);
	}

	std::string encryptHex(const std::string& sData)
	{
		return hexEncode(encrypt(sData));
	}

	std::string decryptHex(const std::string& sData)
	{
		return decrypt(hexDecode(sData));
	}

public:

	static std::string hexEncode(const std::string& sData)
	{
		static char chMap[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
		std::string sResult(sData.size()*2, (char)0);
		for (size_t i=0; i<sData.size(); ++i)
		{
			sResult[i*2] = chMap[((unsigned char)sData[i])/16];
			sResult[i*2+1] = chMap[((unsigned char)sData[i])%16];
		}
		return sResult;
	}

	static std::string hexDecode(const std::string& sData)
	{
		if (sData.size()%2 != 0)
		{
			return "";
		}

		static int MAPX[256] = 
		{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		};

		std::string sResult(sData.size()/2, (char)0);
		for (size_t i=0, n=0; i<sData.size(); i+=2,n+=1)
		{
			sResult[n] = (MAPX[((const unsigned char)sData[i])]<<0x04)|(MAPX[((const unsigned char)sData[i+1])]);
		}
		return sResult;
	}

protected:
	AES_KEY m_keyEncrypt;
	AES_KEY m_keyDecrypt;
};

typedef CAES<128> CAES128;

#endif
